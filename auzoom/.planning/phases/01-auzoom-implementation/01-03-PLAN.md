---
phase: 01-auzoom-implementation
plan: 03
type: execute
---

<objective>
Build MCP server that replaces file reading with hierarchical navigation, intercepting Read operations to provide progressive disclosure for Python files and cached summaries for other files.

Purpose: Make AuZoom transparent to Claude Code - automatically optimize token usage on every file read without workflow changes.

Output: MCP server exposing `auzoom_read` tool that replaces normal Read, with LazyCodeGraph backend handling Python files and summary cache for non-Python files.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-auzoom-implementation/01-01-SUMMARY.md
@.planning/phases/01-auzoom-implementation/01-02-v2-SUMMARY.md

**Existing code**:
@auzoom/src/auzoom/models.py
@auzoom/src/auzoom/parser.py
@auzoom/src/auzoom/lazy_graph.py

**Tech stack available**: LazyCodeGraph with lazy loading and caching (already built)

**Architecture decision**: Tool replacement (not resource interception or prompt-based)

**Key requirements**:
1. Replace Read tool with `auzoom_read`
2. Python files: Always start skeleton, explicit level requests
3. Non-Python files: Return cached summary if exists, else full + background summarize
4. Enforce good practices: small files/functions
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement MCP server with auzoom_read tool</name>
  <files>auzoom/src/auzoom/mcp_server.py</files>
  <action>
Create MCP server that exposes `auzoom_read` tool:

```python
import json
import sys
from pathlib import Path
from typing import Optional, Literal
from .lazy_graph import LazyCodeGraph
from .models import FetchLevel


class AuZoomMCPServer:
    """MCP server that replaces Read with hierarchical file navigation.

    Tool: auzoom_read(path, level="skeleton")
    - Python files: Return parsed structure at requested level
    - Other files: Return cached summary or full content
    """

    def __init__(self, project_root: str):
        self.project_root = Path(project_root).resolve()
        self.graph = LazyCodeGraph(str(self.project_root), auto_warm=True)

        # Summary cache for non-Python files
        self.summary_cache_dir = self.project_root / ".auzoom" / "summaries"
        self.summary_cache_dir.mkdir(parents=True, exist_ok=True)

    def _get_tools_manifest(self) -> dict:
        """Return MCP tools manifest."""
        return {
            "tools": [
                {
                    "name": "auzoom_read",
                    "description": "Read file with hierarchical navigation. Python files return structure at requested level (skeleton/summary/full). Other files return cached summary or full content.",
                    "inputSchema": {
                        "type": "object",
                        "properties": {
                            "path": {
                                "type": "string",
                                "description": "File path to read"
                            },
                            "level": {
                                "type": "string",
                                "enum": ["skeleton", "summary", "full"],
                                "default": "skeleton",
                                "description": "Detail level for Python files: skeleton (15 tokens/node), summary (75 tokens/node), or full (400 tokens/node)"
                            },
                            "offset": {
                                "type": "integer",
                                "description": "Line offset for partial reads (optional)"
                            },
                            "limit": {
                                "type": "integer",
                                "description": "Line limit for partial reads (optional)"
                            }
                        },
                        "required": ["path"]
                    }
                },
                {
                    "name": "auzoom_find",
                    "description": "Search for code by name pattern across indexed files",
                    "inputSchema": {
                        "type": "object",
                        "properties": {
                            "pattern": {
                                "type": "string",
                                "description": "Name pattern to search for"
                            }
                        },
                        "required": ["pattern"]
                    }
                },
                {
                    "name": "auzoom_get_dependencies",
                    "description": "Get dependency graph for a node",
                    "inputSchema": {
                        "type": "object",
                        "properties": {
                            "node_id": {
                                "type": "string",
                                "description": "Node ID to analyze"
                            },
                            "depth": {
                                "type": "integer",
                                "default": 1,
                                "description": "Dependency depth to traverse"
                            }
                        },
                        "required": ["node_id"]
                    }
                },
                {
                    "name": "auzoom_stats",
                    "description": "Get cache performance statistics",
                    "inputSchema": {
                        "type": "object",
                        "properties": {}
                    }
                }
            ]
        }

    def handle_tool_call(self, tool_name: str, arguments: dict) -> dict:
        """Dispatch tool calls to appropriate handlers."""
        try:
            if tool_name == "auzoom_read":
                return self._tool_read(arguments)
            elif tool_name == "auzoom_find":
                return self._tool_find(arguments)
            elif tool_name == "auzoom_get_dependencies":
                return self._tool_get_dependencies(arguments)
            elif tool_name == "auzoom_stats":
                return self._tool_stats(arguments)
            else:
                return {"error": f"Unknown tool: {tool_name}"}
        except Exception as e:
            return {"error": str(e), "type": type(e).__name__}

    def _tool_read(self, args: dict) -> dict:
        """Handle auzoom_read - the main file reading tool.

        Flow:
        1. Check if Python file
        2. Python: Return hierarchical view from LazyCodeGraph
        3. Other: Check summary cache, else read full + background summarize
        """
        path = args.get("path")
        level_str = args.get("level", "skeleton")
        offset = args.get("offset")
        limit = args.get("limit")

        if not path:
            return {"error": "path parameter required"}

        # Resolve path
        file_path = Path(path)
        if not file_path.is_absolute():
            file_path = self.project_root / path

        file_path = file_path.resolve()

        if not file_path.exists():
            return {"error": f"File not found: {path}"}

        # Python files: Use LazyCodeGraph
        if file_path.suffix == ".py":
            return self._read_python_file(str(file_path), level_str)

        # Non-Python files: Check summary cache
        return self._read_non_python_file(file_path, offset, limit)

    def _read_python_file(self, file_path: str, level_str: str) -> dict:
        """Read Python file using LazyCodeGraph."""
        level = FetchLevel[level_str.upper()]

        try:
            nodes = self.graph.get_file(file_path, level)

            return {
                "type": "python",
                "file_path": file_path,
                "level": level_str,
                "nodes": nodes,
                "node_count": len(nodes),
                "token_estimate": self._estimate_response_tokens(nodes)
            }
        except Exception as e:
            # Fallback: return raw file content
            return {
                "type": "python_fallback",
                "file_path": file_path,
                "error": f"Parse failed: {e}",
                "content": Path(file_path).read_text()
            }

    def _read_non_python_file(
        self,
        file_path: Path,
        offset: Optional[int] = None,
        limit: Optional[int] = None
    ) -> dict:
        """Read non-Python file with summary caching.

        Strategy:
        1. Check if summary exists in cache
        2. If yes: Return summary + metadata
        3. If no: Return full content + trigger background summarization
        """
        # Check cache
        cached_summary = self._load_summary_cache(file_path)

        if cached_summary:
            return {
                "type": "cached_summary",
                "file_path": str(file_path),
                "summary": cached_summary["summary"],
                "file_type": cached_summary["file_type"],
                "line_count": cached_summary["line_count"],
                "note": "Full content available via auzoom_read(level='full')"
            }

        # No cache: Return full content
        content = file_path.read_text()
        lines = content.splitlines()

        # Apply offset/limit if specified
        if offset is not None or limit is not None:
            offset = offset or 0
            limit = limit or len(lines)
            lines = lines[offset:offset + limit]
            content = '\n'.join(lines)

        # Trigger background summarization
        self._schedule_summarization(file_path, content)

        return {
            "type": "full_content",
            "file_path": str(file_path),
            "content": content,
            "line_count": len(lines),
            "note": "Summary will be cached for future reads"
        }

    def _load_summary_cache(self, file_path: Path) -> Optional[dict]:
        """Load cached summary for non-Python file."""
        import hashlib

        # Compute cache key
        content_hash = hashlib.sha256(file_path.read_bytes()).hexdigest()[:8]
        cache_file = self.summary_cache_dir / f"{file_path.name}_{content_hash}.json"

        if cache_file.exists():
            return json.loads(cache_file.read_text())

        return None

    def _schedule_summarization(self, file_path: Path, content: str):
        """Schedule background summarization for non-Python file.

        Note: V1 implementation - just creates a placeholder.
        V2 will use Claude Code via callback to generate summary.
        """
        import threading

        def summarize():
            # TODO: V2 - Ask Claude Code to summarize
            # For now, create basic metadata summary
            lines = content.splitlines()
            summary = {
                "summary": f"File: {file_path.name}\nLines: {len(lines)}\nType: {file_path.suffix}",
                "file_type": file_path.suffix,
                "line_count": len(lines),
                "generated_at": self._timestamp()
            }

            # Cache it
            import hashlib
            content_hash = hashlib.sha256(file_path.read_bytes()).hexdigest()[:8]
            cache_file = self.summary_cache_dir / f"{file_path.name}_{content_hash}.json"
            cache_file.write_text(json.dumps(summary, indent=2))

        thread = threading.Thread(target=summarize, daemon=True)
        thread.start()

    def _tool_find(self, args: dict) -> dict:
        """Search for code by name pattern."""
        pattern = args.get("pattern", "")
        matches = self.graph.find_by_name(pattern)

        return {
            "matches": matches,
            "count": len(matches)
        }

    def _tool_get_dependencies(self, args: dict) -> dict:
        """Get dependency graph for a node."""
        node_id = args.get("node_id")
        depth = args.get("depth", 1)

        if not node_id:
            return {"error": "node_id parameter required"}

        deps = self.graph.get_dependencies(node_id, depth)

        return {
            "node_id": node_id,
            "dependencies": deps,
            "count": len(deps)
        }

    def _tool_stats(self, args: dict) -> dict:
        """Get cache performance statistics."""
        return self.graph.get_stats()

    def _estimate_response_tokens(self, nodes: list) -> int:
        """Estimate token count for response."""
        from .models import estimate_tokens
        return estimate_tokens(str(nodes))

    def _timestamp(self) -> str:
        """ISO timestamp."""
        from datetime import datetime
        return datetime.utcnow().isoformat() + "Z"

    def run(self):
        """Run MCP server (stdio protocol)."""
        # Read requests from stdin, write responses to stdout
        for line in sys.stdin:
            try:
                request = json.loads(line.strip())

                # Handle different message types
                if request.get("method") == "tools/list":
                    response = {
                        "jsonrpc": "2.0",
                        "id": request.get("id"),
                        "result": self._get_tools_manifest()
                    }
                elif request.get("method") == "tools/call":
                    params = request.get("params", {})
                    tool_name = params.get("name")
                    arguments = params.get("arguments", {})

                    result = self.handle_tool_call(tool_name, arguments)

                    response = {
                        "jsonrpc": "2.0",
                        "id": request.get("id"),
                        "result": {
                            "content": [
                                {
                                    "type": "text",
                                    "text": json.dumps(result, indent=2)
                                }
                            ]
                        }
                    }
                else:
                    response = {
                        "jsonrpc": "2.0",
                        "id": request.get("id"),
                        "error": {
                            "code": -32601,
                            "message": f"Method not found: {request.get('method')}"
                        }
                    }

                print(json.dumps(response), flush=True)

            except json.JSONDecodeError as e:
                error_response = {
                    "jsonrpc": "2.0",
                    "id": None,
                    "error": {
                        "code": -32700,
                        "message": f"Parse error: {e}"
                    }
                }
                print(json.dumps(error_response), flush=True)
            except Exception as e:
                error_response = {
                    "jsonrpc": "2.0",
                    "id": request.get("id") if 'request' in locals() else None,
                    "error": {
                        "code": -32603,
                        "message": f"Internal error: {e}"
                    }
                }
                print(json.dumps(error_response), flush=True)


def main():
    """Entry point for MCP server."""
    import os
    project_root = os.getcwd()
    server = AuZoomMCPServer(project_root)
    server.run()


if __name__ == "__main__":
    main()
```

Key features:
- Replaces Read with `auzoom_read`
- Python files: Progressive disclosure (skeleton → summary → full)
- Non-Python files: Cached summaries with background generation
- MCP JSON-RPC protocol compliant
- Stdio transport (stdin/stdout)

  </action>
  <verify>
# Test server initialization
PYTHONPATH=src:$PYTHONPATH python3 -c "
from auzoom.mcp_server import AuZoomMCPServer
server = AuZoomMCPServer('.')
print('Server initialized')
print(f'Tools: {len(server._get_tools_manifest()[\"tools\"])}')
"
  </verify>
  <done>MCP server initializes, exposes tools, ready for tool calls</done>
</task>

<task type="auto">
  <name>Task 2: Create CLI entry point for MCP server</name>
  <files>auzoom/src/auzoom/__init__.py, auzoom/pyproject.toml</files>
  <action>
Update package exports and add MCP server entry point:

```python
# __init__.py
from .models import CodeNode, FetchLevel, NodeType
from .parser import PythonParser
from .lazy_graph import LazyCodeGraph
from .mcp_server import AuZoomMCPServer

__version__ = "0.3.0"
__all__ = [
    "CodeNode",
    "FetchLevel",
    "NodeType",
    "PythonParser",
    "LazyCodeGraph",
    "AuZoomMCPServer"
]
```

Update pyproject.toml scripts:
```toml
[project.scripts]
auzoom = "auzoom.cli:main"
auzoom-mcp = "auzoom.mcp_server:main"
```

This creates `auzoom-mcp` command for running the MCP server.

  </action>
  <verify>
# Verify entry point exists
python3 -c "from auzoom.mcp_server import main; print('Entry point OK')"
  </verify>
  <done>CLI entry point configured, auzoom-mcp command available</done>
</task>

<task type="auto">
  <name>Task 3: Create MCP server integration tests</name>
  <files>tests/test_mcp_server.py</files>
  <action>
Test MCP server tool calls and file reading:

```python
import pytest
import json
from pathlib import Path
from auzoom.mcp_server import AuZoomMCPServer


@pytest.fixture
def server():
    """Create server instance for testing."""
    return AuZoomMCPServer('.')


def test_server_initialization(server):
    """Test server initializes correctly."""
    assert server.project_root is not None
    assert server.graph is not None
    assert server.summary_cache_dir.exists()


def test_tools_manifest(server):
    """Test tools manifest structure."""
    manifest = server._get_tools_manifest()

    assert "tools" in manifest
    assert len(manifest["tools"]) == 4  # read, find, dependencies, stats

    # Check auzoom_read tool
    read_tool = next(t for t in manifest["tools"] if t["name"] == "auzoom_read")
    assert "inputSchema" in read_tool
    assert "path" in read_tool["inputSchema"]["properties"]
    assert "level" in read_tool["inputSchema"]["properties"]


def test_read_python_file_skeleton(server):
    """Test reading Python file at skeleton level."""
    result = server.handle_tool_call("auzoom_read", {
        "path": "src/auzoom/models.py",
        "level": "skeleton"
    })

    assert result["type"] == "python"
    assert result["level"] == "skeleton"
    assert "nodes" in result
    assert len(result["nodes"]) > 0

    # Skeleton should be compact
    node = result["nodes"][0]
    assert "id" in node
    assert "name" in node
    assert "type" in node


def test_read_python_file_full(server):
    """Test reading Python file at full level."""
    result = server.handle_tool_call("auzoom_read", {
        "path": "src/auzoom/models.py",
        "level": "full"
    })

    assert result["type"] == "python"
    assert result["level"] == "full"
    assert "nodes" in result

    # Full should include source
    node = result["nodes"][0]
    if node.get("type") != "import":
        assert "source" in node or "children" in node


def test_read_non_python_file(server):
    """Test reading non-Python file."""
    # Create a test file
    test_file = Path("test_readme.md")
    test_file.write_text("# Test\n\nThis is a test file.\n")

    try:
        result = server.handle_tool_call("auzoom_read", {
            "path": str(test_file)
        })

        # First read: should return full content
        assert result["type"] == "full_content"
        assert "content" in result
        assert "# Test" in result["content"]

        # TODO: Second read should return cached summary (after background task completes)

    finally:
        test_file.unlink()


def test_find_tool(server):
    """Test auzoom_find tool."""
    result = server.handle_tool_call("auzoom_find", {
        "pattern": "CodeNode"
    })

    assert "matches" in result
    assert "count" in result
    assert result["count"] > 0


def test_get_dependencies_tool(server):
    """Test auzoom_get_dependencies tool."""
    # First find a node
    find_result = server.handle_tool_call("auzoom_find", {
        "pattern": "CodeNode"
    })

    if find_result["matches"]:
        node_id = find_result["matches"][0]["id"]

        result = server.handle_tool_call("auzoom_get_dependencies", {
            "node_id": node_id,
            "depth": 1
        })

        assert "node_id" in result
        assert "dependencies" in result
        assert "count" in result


def test_stats_tool(server):
    """Test auzoom_stats tool."""
    result = server.handle_tool_call("auzoom_stats", {})

    assert "cache_hits" in result
    assert "cache_misses" in result
    assert "hit_rate" in result
    assert "files_parsed" in result


def test_error_handling(server):
    """Test error handling for invalid requests."""
    # Missing path
    result = server.handle_tool_call("auzoom_read", {})
    assert "error" in result

    # Non-existent file
    result = server.handle_tool_call("auzoom_read", {
        "path": "nonexistent.py"
    })
    assert "error" in result

    # Unknown tool
    result = server.handle_tool_call("unknown_tool", {})
    assert "error" in result


def test_progressive_disclosure(server):
    """Test that levels provide progressive detail."""
    skeleton = server.handle_tool_call("auzoom_read", {
        "path": "src/auzoom/models.py",
        "level": "skeleton"
    })

    summary = server.handle_tool_call("auzoom_read", {
        "path": "src/auzoom/models.py",
        "level": "summary"
    })

    full = server.handle_tool_call("auzoom_read", {
        "path": "src/auzoom/models.py",
        "level": "full"
    })

    # Should have increasing detail
    skeleton_size = len(json.dumps(skeleton))
    summary_size = len(json.dumps(summary))
    full_size = len(json.dumps(full))

    assert skeleton_size < summary_size < full_size
    print(f"Sizes - Skeleton: {skeleton_size}, Summary: {summary_size}, Full: {full_size}")
```

Run: pytest tests/test_mcp_server.py -v -s

  </action>
  <verify>
cd auzoom && PYTHONPATH=src:$PYTHONPATH python3 -m pytest tests/test_mcp_server.py -v -s
  </verify>
  <done>All MCP server tests pass, tool calls working correctly</done>
</task>

<task type="auto">
  <name>Task 4: Create MCP plugin configuration</name>
  <files>.claude-plugin/plugin.json, .claude-plugin/mcp-config.json</files>
  <action>
Create plugin configuration for Claude Code integration:

```json
// .claude-plugin/plugin.json
{
  "name": "auzoom",
  "version": "0.3.0",
  "description": "Multi-resolution code navigation with hierarchical file reading",
  "author": {
    "name": "AuZoom Team"
  },
  "license": "MIT",
  "mcp_servers": [
    {
      "name": "auzoom",
      "command": "auzoom-mcp",
      "args": [],
      "env": {}
    }
  ]
}
```

```json
// .claude-plugin/mcp-config.json
{
  "mcpServers": {
    "auzoom": {
      "command": "python3",
      "args": [
        "-m",
        "auzoom.mcp_server"
      ],
      "env": {
        "PYTHONPATH": "${workspaceFolder}/auzoom/src"
      }
    }
  }
}
```

Create README for MCP usage:
```markdown
# AuZoom MCP Server

## Installation

```bash
cd auzoom
pip install -e .
```

## Configuration

Add to your Claude Code MCP settings:

```json
{
  "mcpServers": {
    "auzoom": {
      "command": "auzoom-mcp"
    }
  }
}
```

## Tools

### auzoom_read
Replacement for Read tool with hierarchical navigation.

**Parameters:**
- `path` (required): File path to read
- `level` (optional): Detail level - "skeleton" (default), "summary", or "full"

**Usage:**
```
auzoom_read path="src/auth.py"  # Returns skeleton
auzoom_read path="src/auth.py" level="full"  # Returns full source
```

### auzoom_find
Search for code by name pattern.

### auzoom_get_dependencies
Get dependency graph for a node.

### auzoom_stats
Get cache performance statistics.
```

  </action>
  <verify>
# Verify plugin config is valid JSON
python3 -c "import json; print(json.load(open('.claude-plugin/plugin.json'))); print('Plugin config OK')"
  </verify>
  <done>Plugin configuration created, ready for Claude Code integration</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] MCP server starts and responds to tool calls
- [ ] `auzoom_read` works for Python files (all levels)
- [ ] `auzoom_read` works for non-Python files (with caching)
- [ ] `auzoom_find` searches by name pattern
- [ ] `auzoom_get_dependencies` traverses dependency graph
- [ ] `auzoom_stats` returns performance metrics
- [ ] All tests pass
- [ ] Plugin configuration valid
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- MCP server follows JSON-RPC protocol
- Tool replacement works transparently
- Progressive disclosure demonstrated (skeleton < summary < full)
- Non-Python file summaries cached for reuse
- Integration tests prove end-to-end functionality

</success_criteria>

<output>
After completion, create `.planning/phases/01-auzoom-implementation/01-03-SUMMARY.md`:

# Phase 1 Plan 03: MCP Server Summary

**MCP server with tool replacement for transparent hierarchical file reading**

## Accomplishments

- MCP server exposing `auzoom_read` as Read replacement
- Python file handling with skeleton/summary/full levels
- Non-Python file caching with background summarization
- Three additional tools: find, get_dependencies, stats
- JSON-RPC protocol compliance
- Full integration tests proving tool functionality
- Plugin configuration for Claude Code integration

## Files Created/Modified

- `auzoom/src/auzoom/mcp_server.py` - MCP server implementation
- `auzoom/src/auzoom/__init__.py` - Package exports updated
- `auzoom/pyproject.toml` - Added `auzoom-mcp` entry point
- `tests/test_mcp_server.py` - MCP server integration tests
- `.claude-plugin/plugin.json` - Plugin configuration
- `.claude-plugin/mcp-config.json` - MCP server configuration

## Decisions Made

- Tool replacement over resource interception (more explicit)
- Always start with skeleton for Python files
- Background summarization for non-Python files
- Simple placeholder summaries for V1 (metadata only)
- V2 will use Claude Code callback for real summarization

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

Phase 1 Complete! Ready for Phase 2 or integration testing.

**What's working:**
- LazyCodeGraph: On-demand parsing with caching
- MCP Server: Tool replacement with progressive disclosure
- End-to-end: Claude Code can use auzoom_read transparently

**What's next:**
- Phase 2: Skills for intelligent navigation workflows
- Or: Integration testing with real Claude Code usage
</output>
