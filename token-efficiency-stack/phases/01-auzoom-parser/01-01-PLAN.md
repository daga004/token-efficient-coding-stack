# PLAN 01-01: AuZoom Data Models & Tree-sitter Setup

## Objective
Establish the foundational data structures and parsing infrastructure for AuZoom. This plan sets up Tree-sitter for Python parsing and implements the core CodeNode model that represents code elements at multiple resolution levels.

## Context
```
@STATE.md
```

Prior specification from conversation "Reducing AI agent token usage":
- CodeNode has: id, name, node_type, level (skeleton/summary/full), content, dependencies, children
- Three levels: skeleton (~15 tokens/node), summary (~75 tokens), full (~400 tokens)
- Tree-sitter chosen for multi-language extensibility

## Tasks

<task type="auto">
  <n>Initialize AuZoom project structure</n>
  <files>
    auzoom/
    auzoom/__init__.py
    auzoom/models.py
    auzoom/parser.py
    pyproject.toml
  </files>
  <action>
    Create Python package structure with:
    - pyproject.toml with dependencies: tree-sitter, tree-sitter-python, pydantic
    - Empty __init__.py
    - Placeholder models.py and parser.py
    Use uv or pip for dependency management.
  </action>
  <verify>
    cd auzoom && python -c "import tree_sitter; print('tree-sitter OK')"
  </verify>
  <done>Project structure exists, tree-sitter imports successfully</done>
</task>

<task type="auto">
  <n>Implement CodeNode data model</n>
  <files>auzoom/models.py</files>
  <action>
    Implement using Pydantic:
    
    class FetchLevel(Enum):
        SKELETON = "skeleton"   # name + dependencies only
        SUMMARY = "summary"     # + docstring/signature
        FULL = "full"          # + complete source
    
    class NodeType(Enum):
        MODULE = "module"
        CLASS = "class"
        FUNCTION = "function"
        METHOD = "method"
        IMPORT = "import"
    
    class CodeNode(BaseModel):
        id: str                          # file_path::qualified_name
        name: str                        # Short name
        node_type: NodeType
        file_path: str
        line_start: int
        line_end: int
        dependencies: list[str]          # IDs of nodes this depends on
        children: list[str]              # IDs of child nodes
        docstring: Optional[str]         # For summary level
        signature: Optional[str]         # For functions/methods
        source: Optional[str]            # For full level
        
        def to_skeleton(self) -> dict: ...
        def to_summary(self) -> dict: ...
        def to_full(self) -> dict: ...
  </action>
  <verify>
    python -c "from auzoom.models import CodeNode, FetchLevel, NodeType; print('Models OK')"
  </verify>
  <done>CodeNode model with three resolution methods implemented</done>
</task>

<task type="auto">
  <n>Implement Tree-sitter Python parser</n>
  <files>auzoom/parser.py</files>
  <action>
    Implement PythonParser class:
    
    class PythonParser:
        def __init__(self):
            # Initialize tree-sitter with Python grammar
            
        def parse_file(self, file_path: str) -> list[CodeNode]:
            # Parse file, return all CodeNodes
            
        def _extract_functions(self, tree, file_path) -> list[CodeNode]:
            # Query for function_definition nodes
            
        def _extract_classes(self, tree, file_path) -> list[CodeNode]:
            # Query for class_definition nodes
            
        def _extract_imports(self, tree, file_path) -> list[CodeNode]:
            # Query for import_statement, import_from_statement
            
        def _resolve_dependencies(self, nodes: list[CodeNode]) -> None:
            # Analyze function bodies for calls to other nodes
    
    Use tree-sitter queries for extraction. Handle:
    - Top-level functions
    - Classes with methods
    - Nested classes
    - Import statements (from X import Y, import X)
  </action>
  <verify>
    Create test file with function, class, imports.
    python -c "from auzoom.parser import PythonParser; p = PythonParser(); nodes = p.parse_file('test.py'); print(f'{len(nodes)} nodes parsed')"
  </verify>
  <done>Parser extracts functions, classes, methods, imports from Python files</done>
</task>

## Verification
- [ ] `tree-sitter` and `tree-sitter-python` installed and working
- [ ] CodeNode model has skeleton/summary/full serialization
- [ ] Parser extracts all top-level definitions from a test file
- [ ] Dependencies between nodes are identified

## Success Criteria
Parse a 200+ line Python file with mixed functions/classes and produce:
- Correct node count
- Accurate line ranges
- Resolved internal dependencies

## Output
Update STATE.md with: nodes parsed, token counts per level, any blockers.
SUMMARY.md only if major issues or stopping.
