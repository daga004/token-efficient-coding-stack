---
phase: 01-auzoom-implementation
plan: 04
type: execute
---

<objective>
Implement validation tools and create GSD expertise skill that teaches structural code discipline for optimal AuZoom efficiency.

Purpose: Enable Claude to generate well-structured, modular code that maximizes AuZoom's hierarchical navigation benefits, with validation to check compliance.

Output: Working `auzoom_validate` tool + GSD expertise skill that embodies structural constraints without blocking standard GSD workflows.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-auzoom-implementation/01-01-SUMMARY.md
@.planning/phases/01-auzoom-implementation/01-02-SUMMARY.md
@.planning/phases/01-auzoom-implementation/01-03-SUMMARY.md

**Existing code**:
@auzoom/src/auzoom/models.py
@auzoom/src/auzoom/parser.py
@auzoom/src/auzoom/graph.py
@auzoom/src/auzoom/server.py

**Integration model**: Complementary to GSD, not blocking
- AuZoom MCP tools available alongside standard tools (Read, Edit, Write)
- GSD expertise skill teaches when to prefer AuZoom navigation
- Structural constraints enforced during code generation via skill
- No hard blocking of standard Read tool for V1

**Structural constraints** (from AuZoom philosophy):
- Functions: ≤50 lines
- Modules: ≤250 lines
- Directories: ≤7 files
- Self-documenting names required
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement auzoom_validate tool</name>
  <files>auzoom/src/auzoom/validator.py, auzoom/src/auzoom/server.py, auzoom/src/auzoom/cli.py</files>
  <action>
Create CodeValidator class that checks structural compliance:

```python
# validator.py
from dataclasses import dataclass
from typing import List
from pathlib import Path

@dataclass
class Violation:
    file: str
    line: int
    type: str  # "function_too_long", "module_too_long", "dir_too_many_files"
    severity: str  # "error", "warning"
    message: str
    current: int
    limit: int

class CodeValidator:
    """Validate code structure for AuZoom compatibility."""

    FUNCTION_MAX_LINES = 50
    MODULE_MAX_LINES = 250
    DIR_MAX_FILES = 7

    def __init__(self):
        self.violations: List[Violation] = []

    def validate_file(self, file_path: str) -> List[Violation]:
        """Check a single Python file for violations."""
        violations = []

        with open(file_path) as f:
            lines = f.readlines()

        # Check module length
        module_lines = len(lines)
        if module_lines > self.MODULE_MAX_LINES:
            violations.append(Violation(
                file=file_path,
                line=1,
                type="module_too_long",
                severity="error",
                message=f"Module exceeds {self.MODULE_MAX_LINES} lines",
                current=module_lines,
                limit=self.MODULE_MAX_LINES
            ))

        # Parse with tree-sitter to check function lengths
        from .parser import PythonParser
        parser = PythonParser()
        nodes = parser.parse_file(file_path)

        for node in nodes:
            if node.node_type.value in ['function', 'method']:
                func_lines = node.line_end - node.line_start + 1
                if func_lines > self.FUNCTION_MAX_LINES:
                    violations.append(Violation(
                        file=file_path,
                        line=node.line_start,
                        type="function_too_long",
                        severity="error",
                        message=f"Function '{node.name}' exceeds {self.FUNCTION_MAX_LINES} lines",
                        current=func_lines,
                        limit=self.FUNCTION_MAX_LINES
                    ))

        return violations

    def validate_directory(self, dir_path: str) -> List[Violation]:
        """Check directory for too many files."""
        violations = []
        path = Path(dir_path)

        if not path.is_dir():
            return violations

        # Count Python files (not subdirectories)
        py_files = list(path.glob("*.py"))
        file_count = len(py_files)

        if file_count > self.DIR_MAX_FILES:
            violations.append(Violation(
                file=str(path),
                line=0,
                type="dir_too_many_files",
                severity="warning",
                message=f"Directory has {file_count} files (limit: {self.DIR_MAX_FILES})",
                current=file_count,
                limit=self.DIR_MAX_FILES
            ))

        return violations

    def validate_project(self, project_root: str) -> List[Violation]:
        """Validate entire project."""
        violations = []
        root = Path(project_root)

        for py_file in root.rglob("*.py"):
            # Skip common ignore patterns
            if any(part in py_file.parts for part in ['.git', '__pycache__', '.venv', 'node_modules']):
                continue

            violations.extend(self.validate_file(str(py_file)))

        # Check directories
        for dir_path in root.rglob("*"):
            if dir_path.is_dir():
                if any(part in dir_path.parts for part in ['.git', '__pycache__', '.venv', 'node_modules']):
                    continue
                violations.extend(self.validate_directory(str(dir_path)))

        return violations

    def format_report(self, violations: List[Violation]) -> str:
        """Format violations as readable report."""
        if not violations:
            return "✓ All files comply with AuZoom structure guidelines"

        errors = [v for v in violations if v.severity == "error"]
        warnings = [v for v in violations if v.severity == "warning"]

        report = []
        report.append(f"\n{'='*60}")
        report.append(f"AuZoom Structure Validation Report")
        report.append(f"{'='*60}\n")

        if errors:
            report.append(f"❌ Errors ({len(errors)}):\n")
            for v in errors:
                report.append(f"  {v.file}:{v.line}")
                report.append(f"    {v.message}")
                report.append(f"    Current: {v.current} lines | Limit: {v.limit} lines")
                report.append("")

        if warnings:
            report.append(f"⚠️  Warnings ({len(warnings)}):\n")
            for v in warnings:
                report.append(f"  {v.file}")
                report.append(f"    {v.message}")
                report.append("")

        return "\n".join(report)
```

Add to server.py:
```python
def _tool_validate(self, args: dict) -> dict:
    """Validate code structure compliance."""
    from .validator import CodeValidator

    scope = args.get("scope", "file")  # "file" | "directory" | "project"
    path = args.get("path", self.project_root)

    validator = CodeValidator()

    if scope == "file":
        violations = validator.validate_file(path)
    elif scope == "directory":
        violations = validator.validate_directory(path)
    else:  # project
        violations = validator.validate_project(path)

    return {
        "violations": [
            {
                "file": v.file,
                "line": v.line,
                "type": v.type,
                "severity": v.severity,
                "message": v.message,
                "current": v.current,
                "limit": v.limit
            }
            for v in violations
        ],
        "compliant": len(violations) == 0
    }
```

Add to cli.py:
```python
@main.command()
@click.option('--scope', type=click.Choice(['file', 'directory', 'project']), default='project')
@click.argument('path', default='.')
def validate(scope, path):
    """Validate code structure compliance."""
    from .validator import CodeValidator

    validator = CodeValidator()

    if scope == "file":
        violations = validator.validate_file(path)
    elif scope == "directory":
        violations = validator.validate_directory(path)
    else:  # project
        violations = validator.validate_project(path)

    report = validator.format_report(violations)
    click.echo(report)

    if any(v.severity == "error" for v in violations):
        raise click.Exit(1)
```

Keep validation simple and actionable. Don't check naming conventions in V1 (too subjective).
  </action>
  <verify>
# Create test file with violations
mkdir -p /tmp/test_validation
cat > /tmp/test_validation/bad.py << 'EOF'
def huge_function():
    """This function is too long."""
    line_1 = 1
    line_2 = 2
    # ... (imagine 60+ lines)
    for i in range(60):
        print(i)
    return True
EOF

cd auzoom && python -c "from auzoom.validator import CodeValidator; v = CodeValidator(); violations = v.validate_file('/tmp/test_validation/bad.py'); print(f'Found {len(violations)} violations'); assert len(violations) > 0"
  </verify>
  <done>Validator detects functions exceeding 50 lines, modules exceeding 250 lines, and directories with >7 files</done>
</task>

<task type="auto">
  <name>Task 2: Create GSD expertise skill for AuZoom structured code</name>
  <files>~/.claude/skills/expertise/auzoom-structured-code/SKILL.md</files>
  <action>
Create GSD expertise skill that teaches structural discipline:

```markdown
# AuZoom Structured Code Expertise

**Domain:** Python codebases using AuZoom for multi-resolution navigation

**Purpose:** Generate modular, well-structured code that maximizes AuZoom's hierarchical navigation efficiency.

## Core Principles

AuZoom works best with **small, focused, self-contained** code units. Every file read has a token cost - structure minimizes navigation needs.

## Structural Constraints

These are HARD LIMITS during code generation:

### Functions & Methods: ≤50 lines
- **Why:** Skeleton view shows signature + dependencies (~15 tokens vs ~400)
- **If approaching limit:** Extract helper functions
- **Pattern:** One function = one clear responsibility

**Example - BAD (75 lines):**
```python
def process_order(order_data):
    # Validation (15 lines)
    # Payment processing (20 lines)
    # Inventory update (15 lines)
    # Email notification (15 lines)
    # Logging (10 lines)
    return result
```

**Example - GOOD:**
```python
def process_order(order_data):
    """Process order through pipeline."""
    validate_order(order_data)
    charge_payment(order_data.payment)
    update_inventory(order_data.items)
    send_confirmation_email(order_data.customer)
    log_order_completion(order_data.id)
    return OrderResult(success=True)

# Each helper: 8-20 lines
def validate_order(data): ...
def charge_payment(payment): ...
def update_inventory(items): ...
```

### Modules: ≤250 lines
- **Why:** File navigation at skeleton level stays under 1000 tokens
- **If approaching limit:** Split by concern (models.py → user_models.py + order_models.py)
- **Pattern:** One module = one cohesive concept

### Directories: ≤7 files
- **Why:** Cognitive load + directory listing token cost
- **If approaching limit:** Create subdirectories by feature area
- **Pattern:** Related files grouped together

## When to Use AuZoom Tools vs Standard Tools

**AuZoom is COMPLEMENTARY to standard GSD tools, not replacing them.**

### Use `auzoom_get_graph(file, level="skeleton")` when:
- Exploring unfamiliar codebase
- Finding which functions to modify
- Understanding file structure before diving deep
- Building context for related functions

### Use standard `Read` tool when:
- You already know exact function to modify (from skeleton navigation)
- Writing/editing code (always use Write/Edit)
- Reading config files, docs, non-code files
- File is small (<100 lines)

### Workflow pattern:
1. **Navigate:** `auzoom_get_graph` with skeleton to find target
2. **Focus:** `auzoom_get_graph(node_id, level="full")` for specific function
3. **Edit:** Use standard `Edit` tool to modify
4. **Validate:** `auzoom_validate` to check structure

## Decomposition Patterns

### Pattern 1: Extract Helper Functions
```python
# Before: 80-line function
def generate_report(data):
    # Parse data (20 lines)
    # Calculate metrics (25 lines)
    # Format output (20 lines)
    # Save to file (15 lines)

# After: 4 focused functions
def generate_report(data):
    parsed = parse_report_data(data)
    metrics = calculate_report_metrics(parsed)
    formatted = format_report_output(metrics)
    save_report_file(formatted)
    return formatted

def parse_report_data(data): ...  # 15 lines
def calculate_report_metrics(parsed): ...  # 20 lines
def format_report_output(metrics): ...  # 18 lines
def save_report_file(formatted): ...  # 12 lines
```

### Pattern 2: Split Modules by Responsibility
```python
# Before: models.py (400 lines)
# All models in one file

# After: Split into focused modules
# models/user.py (80 lines) - User, UserProfile, UserSettings
# models/order.py (90 lines) - Order, OrderItem, OrderStatus
# models/payment.py (60 lines) - Payment, Invoice, Refund
# models/__init__.py (15 lines) - Re-exports
```

### Pattern 3: Subdirectories for Feature Areas
```
# Before: services/ (12 files)
# Too many files in one directory

# After: Group by domain
services/
  auth/
    login.py
    register.py
    session.py
  payments/
    stripe.py
    invoices.py
    refunds.py
  notifications/
    email.py
    sms.py
```

## Integration with GSD Workflows

During **plan execution**:
- GSD loads this skill for Python projects with AuZoom
- Tasks include decomposition hints in `<action>` elements
- Post-execution validation optional but recommended

During **code generation**:
- Check line count as you write
- If function approaching 40 lines → extract helpers
- If module approaching 200 lines → plan split before continuing

## Validation

After code changes, optionally run:
```bash
auzoom validate --scope project .
```

Violations are suggestions, not blockers - but address them for optimal AuZoom efficiency.

## References Index

**When planning phases involving:**

- **New Python modules** → Include this skill, emphasize ≤250 line limit in task actions
- **Function implementation** → Remind: ≤50 lines, extract helpers if needed
- **Package organization** → Suggest subdirectories at 7+ files
- **Refactoring** → Perfect time to enforce structure, use `auzoom_validate` first

## Anti-Patterns

❌ **"Just one more feature"** - Don't let functions grow past 50 lines "just this once"
❌ **God objects** - 500-line modules with everything
❌ **Flat structure** - 20 files in one directory
❌ **Premature abstraction** - Don't split just to hit numbers; split for clarity

✅ **Progressive refinement** - Write functionally, refactor to structure
✅ **Single Responsibility** - Each unit does one thing well
✅ **Self-documenting names** - Code that explains itself
```

Install to: `~/.claude/skills/expertise/auzoom-structured-code/SKILL.md`

This skill is LOADED during phase planning when GSD detects Python project with AuZoom. It guides code generation without blocking standard tools.
  </action>
  <verify>
# Create the skill directory and file
mkdir -p ~/.claude/skills/expertise/auzoom-structured-code
cat ~/.claude/skills/expertise/auzoom-structured-code/SKILL.md | head -20
echo "Skill file created at expected location"
  </verify>
  <done>GSD expertise skill created at ~/.claude/skills/expertise/auzoom-structured-code/SKILL.md</done>
</task>

<task type="auto">
  <name>Task 3: Create documentation and update MCP server</name>
  <files>auzoom/docs/CODING-STANDARD.md, auzoom/src/auzoom/server.py</files>
  <action>
Create user-facing coding standard documentation:

```markdown
# AuZoom Coding Standard

Code structure for optimal multi-resolution navigation.

## Size Limits

| Unit | Maximum | Rationale |
|------|---------|-----------|
| Function/Method | 50 lines | Fits in summary view (~75 tokens) |
| Module | 250 lines | Skeleton view under 1000 tokens |
| Directory | 7 files | Cognitive load + listing cost |

## Validation

Check compliance:
```bash
auzoom validate --scope project .
```

## Enforcement

Limits are enforced via:
1. **GSD expertise skill** - Guides code generation
2. **auzoom_validate tool** - Checks existing code
3. **Code review** - Team standards

## Decomposition Guide

### When function approaches 40 lines:
1. Identify logical sections
2. Extract each as helper function
3. Main function becomes coordinator

### When module approaches 200 lines:
1. Group related classes/functions
2. Split into focused modules
3. Use `__init__.py` for re-exports

### When directory reaches 7 files:
1. Identify feature groupings
2. Create subdirectories
3. Keep related code together

See GSD skill documentation for detailed patterns.
```

Add `auzoom_validate` to MCP server tool list in `server.py`:

```python
def handle_tool_call(self, tool_name: str, arguments: dict[str, Any]) -> dict:
    """Dispatch tool calls to appropriate handlers."""
    if tool_name == "auzoom_get_graph":
        return self._tool_get_graph(arguments)
    elif tool_name == "auzoom_find":
        return self._tool_find(arguments)
    elif tool_name == "auzoom_get_dependencies":
        return self._tool_get_dependencies(arguments)
    elif tool_name == "auzoom_validate":
        return self._tool_validate(arguments)
    else:
        return {"error": f"Unknown tool: {tool_name}"}
```

Update auzoom/README.md to mention complementary approach:

```markdown
## Integration with GSD

AuZoom works **alongside** standard GSD tools (Read, Edit, Write):

- **Navigation:** Use `auzoom_get_graph` to explore
- **Editing:** Use standard `Edit` tool to modify
- **Validation:** Use `auzoom_validate` to check structure

The GSD expertise skill teaches when to use each tool.
```
  </action>
  <verify>
cat auzoom/docs/CODING-STANDARD.md | grep "50 lines"
grep "auzoom_validate" auzoom/src/auzoom/server.py
  </verify>
  <done>Documentation created, MCP server updated with validate tool, README clarifies complementary approach</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `auzoom validate` CLI command works
- [ ] Validator detects violations (functions >50 lines, modules >250, directories >7 files)
- [ ] GSD expertise skill installed at correct location
- [ ] MCP server exposes `auzoom_validate` tool
- [ ] Documentation describes complementary (not blocking) approach
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Validator correctly identifies structural violations
- GSD skill teaches structural discipline without blocking standard tools
- Phase 1 complete: AuZoom ready for complementary GSD integration
</success_criteria>

<output>
After completion, create `.planning/phases/01-auzoom-implementation/01-04-SUMMARY.md`:

# Phase 1 Plan 04: Validation & GSD Skill Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- CodeValidator with structural compliance checking
- GSD expertise skill for AuZoom structured code
- `auzoom_validate` tool in CLI and MCP server
- CODING-STANDARD.md documentation
- Complementary integration model confirmed

## Files Created/Modified

- `auzoom/src/auzoom/validator.py` - Validation implementation
- `~/.claude/skills/expertise/auzoom-structured-code/SKILL.md` - GSD expertise
- `auzoom/docs/CODING-STANDARD.md` - User documentation
- `auzoom/src/auzoom/server.py` - Added validate tool
- `auzoom/src/auzoom/cli.py` - Added validate command
- `auzoom/README.md` - Clarified complementary approach

## Decisions Made

- Complementary model: AuZoom alongside standard tools, not blocking
- Hard limits: ≤50 lines/function, ≤250 lines/module, ≤7 files/directory
- GSD skill teaches usage, doesn't enforce (guidance > gatekeeping)
- Validation as optional post-generation check

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Phase Readiness

**Phase 1 Complete**: AuZoom MCP server + validation + GSD skill ready

Next: Phase 2 (Orchestrator) or Phase 3 (GSD Integration with skill activation)
</output>
