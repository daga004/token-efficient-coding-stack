---
phase: 01-auzoom-implementation
plan: 02
type: execute
---

<objective>
Implement the CodeGraph container that stores and navigates CodeNodes with multi-resolution fetch capabilities.

Purpose: Enable efficient graph traversal and context assembly by fetching code at appropriate resolution levels (skeleton/summary/full) based on agent needs.

Output: CodeGraph class with navigation methods that return nodes at requested fetch levels, demonstrating 10x+ token reduction for skeleton vs full views.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-phase.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-auzoom-implementation/01-01-SUMMARY.md

**Existing code**:
@auzoom/src/auzoom/models.py
@auzoom/src/auzoom/parser.py

**Tech stack available**: Completed parser from 01-01, CodeNode with three fetch levels

**Constraining decisions**:
- Token targets: skeleton ~15, summary ~75, full ~400 per node
- Mandatory navigation: no bypass to reading full files directly
- Dependency traversal for context assembly
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CodeGraph container with indexing</name>
  <files>auzoom/src/auzoom/graph.py</files>
  <action>
Create CodeGraph class that stores and indexes CodeNodes:

```python
from .models import CodeNode, FetchLevel, NodeType

class CodeGraph:
    """Container for navigating code structure at multiple resolutions."""

    def __init__(self):
        self.nodes: dict[str, CodeNode] = {}  # node_id -> CodeNode
        self.file_index: dict[str, list[str]] = {}  # file_path -> [node_ids]
        self.name_index: dict[str, list[str]] = {}  # name -> [node_ids] for search

    def add_node(self, node: CodeNode) -> None:
        """Add node and update indexes."""
        self.nodes[node.id] = node

        # Update file index
        if node.file_path not in self.file_index:
            self.file_index[node.file_path] = []
        self.file_index[node.file_path].append(node.id)

        # Update name index
        if node.name not in self.name_index:
            self.name_index[node.name] = []
        self.name_index[node.name].append(node.id)

    def get_node(self, node_id: str, level: FetchLevel) -> dict:
        """Get single node at requested resolution."""
        node = self.nodes.get(node_id)
        if not node:
            raise KeyError(f"Node {node_id} not found")

        if level == FetchLevel.SKELETON:
            return node.to_skeleton()
        elif level == FetchLevel.SUMMARY:
            return node.to_summary()
        else:  # FULL
            return node.to_full()

    def get_file(self, file_path: str, level: FetchLevel) -> list[dict]:
        """Get all nodes in a file at requested resolution."""
        node_ids = self.file_index.get(file_path, [])
        return [self.get_node(nid, level) for nid in node_ids]

    def get_children(self, node_id: str, level: FetchLevel) -> list[dict]:
        """Get child nodes (e.g., methods of a class)."""
        node = self.nodes.get(node_id)
        if not node:
            return []
        return [self.get_node(cid, level) for cid in node.children]

    def get_dependencies(self, node_id: str, depth: int = 1) -> list[dict]:
        """Get dependency nodes (what this node depends on)."""
        if depth < 1:
            return []

        visited = set()
        result = []

        def traverse(nid, d):
            if d > depth or nid in visited:
                return
            visited.add(nid)

            node = self.nodes.get(nid)
            if not node:
                return

            for dep_id in node.dependencies:
                if dep_id not in visited:
                    result.append(self.get_node(dep_id, FetchLevel.SKELETON))
                    traverse(dep_id, d + 1)

        traverse(node_id, 1)
        return result

    def find_by_name(self, name_pattern: str) -> list[dict]:
        """Search for nodes by name (simple substring match)."""
        matches = []
        for name, node_ids in self.name_index.items():
            if name_pattern.lower() in name.lower():
                for nid in node_ids:
                    matches.append(self.get_node(nid, FetchLevel.SKELETON))
        return matches
```

Keep it focused on navigation. Avoid complex query language for V1.
  </action>
  <verify>python -c "from auzoom.graph import CodeGraph; from auzoom.models import CodeNode, FetchLevel; g = CodeGraph(); n = CodeNode(id='test', name='foo', node_type='function', file_path='test.py', line_start=1, line_end=10, dependencies=[], children=[]); g.add_node(n); print(g.get_node('test', FetchLevel.SKELETON))"</verify>
  <done>CodeGraph stores nodes, indexes by file and name, retrieves at any fetch level</done>
</task>

<task type="auto">
  <name>Task 2: Add token counting and validation</name>
  <files>auzoom/src/auzoom/graph.py</files>
  <action>
Add method to CodeGraph for token analysis:

```python
def get_token_stats(self, file_path: str) -> dict:
    """Compare token usage across fetch levels for a file."""
    from .models import CodeNode

    node_ids = self.file_index.get(file_path, [])
    if not node_ids:
        return {"error": "File not found"}

    skeleton_tokens = 0
    summary_tokens = 0
    full_tokens = 0

    for nid in node_ids:
        node = self.nodes[nid]
        skeleton_tokens += node.estimate_tokens(str(node.to_skeleton()))
        summary_tokens += node.estimate_tokens(str(node.to_summary()))
        full_tokens += node.estimate_tokens(str(node.to_full()))

    return {
        "file": file_path,
        "nodes": len(node_ids),
        "tokens_skeleton": skeleton_tokens,
        "tokens_summary": summary_tokens,
        "tokens_full": full_tokens,
        "reduction_ratio": full_tokens / skeleton_tokens if skeleton_tokens > 0 else 0
    }
```

This helps measure AuZoom's effectiveness. Add estimate_tokens method to CodeNode if not already present.
  </action>
  <verify>python -c "from auzoom.graph import CodeGraph; from auzoom.parser import PythonParser; p = PythonParser(); g = CodeGraph(); nodes = p.parse_file('auzoom/src/auzoom/models.py'); [g.add_node(n) for n in nodes]; stats = g.get_token_stats('auzoom/src/auzoom/models.py'); print(f'Reduction: {stats[\"reduction_ratio\"]:.1f}x'); assert stats['reduction_ratio'] > 5"</verify>
  <done>Token stats show ≥5x reduction from full to skeleton</done>
</task>

<task type="auto">
  <name>Task 3: Create graph integration test</name>
  <files>tests/test_graph.py</files>
  <action>
Test CodeGraph navigation with realistic scenarios:

```python
import pytest
from auzoom.parser import PythonParser
from auzoom.graph import CodeGraph
from auzoom.models import FetchLevel

def test_graph_navigation():
    """Test building and navigating a code graph."""
    test_code = '''
def helper():
    """A helper function."""
    return 42

class Calculator:
    def add(self, a, b):
        """Add two numbers using helper."""
        return helper() + a + b

    def multiply(self, a, b):
        return a * b
'''
    with open('/tmp/test_nav.py', 'w') as f:
        f.write(test_code)

    parser = PythonParser()
    graph = CodeGraph()

    nodes = parser.parse_file('/tmp/test_nav.py')
    for node in nodes:
        graph.add_node(node)

    # Test file-level fetch
    skeleton_view = graph.get_file('/tmp/test_nav.py', FetchLevel.SKELETON)
    assert len(skeleton_view) >= 3  # helper, Calculator, methods

    # Test individual node fetch at different levels
    calc_id = [n.id for n in nodes if n.name == 'Calculator'][0]
    skeleton = graph.get_node(calc_id, FetchLevel.SKELETON)
    summary = graph.get_node(calc_id, FetchLevel.SUMMARY)
    full = graph.get_node(calc_id, FetchLevel.FULL)

    assert 'id' in skeleton
    assert 'name' in skeleton
    assert len(str(summary)) > len(str(skeleton))
    assert len(str(full)) > len(str(summary))

def test_dependency_traversal():
    """Test traversing dependencies."""
    test_code = '''
def leaf():
    return 1

def middle():
    return leaf()

def top():
    return middle()
'''
    with open('/tmp/test_deps.py', 'w') as f:
        f.write(test_code)

    parser = PythonParser()
    graph = CodeGraph()

    nodes = parser.parse_file('/tmp/test_deps.py')
    for node in nodes:
        graph.add_node(node)

    top_id = [n.id for n in nodes if n.name == 'top'][0]
    deps = graph.get_dependencies(top_id, depth=2)

    # Should find middle (depth 1) and leaf (depth 2)
    dep_names = [d['name'] for d in deps]
    assert 'middle' in dep_names
    assert 'leaf' in dep_names

def test_token_reduction():
    """Verify skeleton provides significant token reduction."""
    parser = PythonParser()
    graph = CodeGraph()

    # Parse a real file from the codebase
    nodes = parser.parse_file('auzoom/src/auzoom/models.py')
    for node in nodes:
        graph.add_node(node)

    stats = graph.get_token_stats('auzoom/src/auzoom/models.py')

    print(f"Token stats: {stats}")

    # Verify reduction
    assert stats['reduction_ratio'] >= 5.0  # At least 5x reduction
    assert stats['tokens_skeleton'] < stats['tokens_summary'] < stats['tokens_full']
```

Run: pytest tests/test_graph.py -v -s
  </action>
  <verify>pytest tests/test_graph.py -v -s</verify>
  <done>Graph tests pass, demonstrating navigation and ≥5x token reduction</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] CodeGraph stores and retrieves nodes at all three fetch levels
- [ ] Dependency traversal works correctly
- [ ] Token stats show ≥5x reduction (skeleton vs full)
- [ ] Tests pass without errors
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- Navigation methods return correct data structures
- Token reduction ratio ≥5x demonstrated
</success_criteria>

<output>
After completion, create `.planning/phases/01-auzoom-implementation/01-02-SUMMARY.md`:

# Phase 1 Plan 02: Graph Navigation Summary

**[Substantive one-liner - what shipped]**

## Accomplishments

- CodeGraph container with multi-level indexing
- Navigation methods for file, node, children, dependencies
- Token counting proving ≥5x reduction
- Integration tests validating graph operations

## Files Created/Modified

- `auzoom/src/auzoom/graph.py` - CodeGraph implementation
- `tests/test_graph.py` - Graph navigation tests

## Decisions Made

[Key decisions and rationale, or "None"]

## Issues Encountered

[Problems and resolutions, or "None"]

## Next Step

Ready for 01-03-PLAN.md (MCP server with tools)
</output>
